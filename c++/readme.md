# 0.5 — Introduction to the Compiler, Linker, and Libraries


Continuing our discussion of this diagram from the previous lesson (**0.4 -- Introduction to C++ development**):

---

## The Software Development Process

Let’s discuss steps 

<img src="pictures/1.png" alt="Diagram of the software development process" width="500">


### Step 4: Compiling Your Source Code

To compile C++ source code files, we use a **C++ compiler**. The compiler sequentially processes each source code (`.cpp`) file and performs two key tasks:

1. **Syntax Checking**  
    The compiler checks your C++ code to ensure it follows the rules of the language. If errors are found, it reports them (with line numbers) and aborts compilation until fixed.

2. **Translation to Machine Code**  
    The compiler translates your C++ code into machine language instructions, storing them in an intermediate file called an **object file**. Object files also contain data needed by the linker (step 5) and for debugging (step 7).

> **Object files** are typically named `name.o` or `name.obj`, where `name` matches the original `.cpp` file.

**Example:**  
If your program has 3 `.cpp` files, the compiler generates 3 object files:

```
main.cpp   →   main.obj
utils.cpp  →   utils.obj
math.cpp   →   math.obj
```

<img src="pictures/2.png" alt="Diagram of the software development process" width="500">

> C++ compilers are available for many operating systems. We’ll discuss installation soon.

---

### Step 5: Linking Object Files and Libraries

After successful compilation, the **linker** combines all object files to produce the desired output file (e.g., an executable). This process is called **linking**.

#### Linking Steps

1. **Read Object Files**  
    The linker reads each object file generated by the compiler and checks validity.

2. **Resolve Dependencies**  
    The linker ensures all cross-file dependencies are resolved. For example, if something is defined in one `.cpp` file and used in another, the linker connects them. Unresolved references cause linker errors.

3. **Link Libraries**  
    The linker typically links in one or more **library files**—collections of precompiled code packaged for reuse.

4. **Output File Creation**  
    The linker produces the final output file, usually an executable, but it could be a library file depending on your project setup.

---

<img src="pictures/3.png" alt="Diagram of the software development process" width="500">

### The Standard Library

The **standard library** provides a set of precompiled, reusable code that can be linked into your programs to extend functionality.

---

> **Summary:**  
> - The **compiler** checks and translates your code into object files.  
> - The **linker** combines object files and libraries to create the final output.


---

## 2.1 — Introduction to Functions

**Alex &nbsp;&nbsp; September 28, 2024**

In the last chapter, we defined a function as a collection of statements that execute sequentially. Let’s update our definition:  
A **function** is a reusable sequence of statements designed to do a particular job.

You already know that every executable program must have a function named `main()` (where execution starts). As programs grow, putting all code inside `main()` becomes hard to manage. Functions let us split programs into small, modular chunks that are easier to organize, test, and reuse. Most programs use many functions. The C++ standard library provides many built-in functions, but you’ll often write your own—called **user-defined functions**.

### Functions in Action

Consider this analogy:  
You’re reading a book and remember you need to make a phone call. You put a bookmark in your book, make the call, and then return to the bookmark to continue reading.

C++ programs work similarly. When a function call is encountered, the CPU “bookmarks” the current location, executes the called function, and then returns to the bookmark to resume execution.

#### Nomenclature

- **Caller**: The function initiating the call.
- **Callee**: The function being called.
- **Invocation**: Another term for a function call.

---

### Defining and Calling Functions

The basic syntax for a user-defined function:

```cpp
returnType functionName() // Function header
{
    // Function body
}
```

- **Function header**: Tells the compiler about the function’s existence, name, and return type.
- **Function body**: Contains the statements that define what the function does.

To call a function, use its name followed by parentheses:

```cpp
functionName();
```

> **Note:**  
> A function must be defined before it can be called (we’ll discuss workarounds in lesson 2.7).

#### Example: Defining and Calling a Function

```cpp
#include <iostream> // for std::cout

void doPrint()
{
    std::cout << "In doPrint()\n";
}

int main()
{
    std::cout << "Starting main()\n";
    doPrint();                        // Call to doPrint()
    std::cout << "Ending main()\n";

    return 0;
}
```

**Output:**
```
Starting main()
In doPrint()
Ending main()
```

> **Warning:**  
> Don’t forget the parentheses when calling a function! Omitting them may cause compilation errors or prevent the function from being called.

---

### Calling Functions Multiple Times

Functions can be called as many times as needed:

```cpp
#include <iostream>

void doPrint()
{
    std::cout << "In doPrint()\n";
}

int main()
{
    std::cout << "Starting main()\n";
    doPrint(); // First call
    doPrint(); // Second call
    std::cout << "Ending main()\n";

    return 0;
}
```

**Output:**
```
Starting main()
In doPrint()
In doPrint()
Ending main()
```

---

### Functions Calling Other Functions

Functions can call other functions, creating a chain of calls:

```cpp
#include <iostream>

void doB()
{
    std::cout << "In doB()\n";
}

void doA()
{
    std::cout << "Starting doA()\n";
    doB();
    std::cout << "Ending doA()\n";
}

int main()
{
    std::cout << "Starting main()\n";
    doA();
    std::cout << "Ending main()\n";

    return 0;
}
```

**Output:**
```
Starting main()
Starting doA()
In doB()
Ending doA()
Ending main()
```

---

### Nested Functions Are Not Supported

C++ does **not** support nested function definitions:

```cpp
#include <iostream>

int main()
{
    void foo() // Illegal: nested inside main()
    {
        std::cout << "foo!\n";
    }

    foo();

    return 0;
}
```

**Correct way:**

```cpp
#include <iostream>

void foo()
{
    std::cout << "foo!\n";
}

int main()
{
    foo();

    return 0;
}
```

---

### Metasyntactic Variables

“foo” is a placeholder name often used for demonstration purposes. Other common placeholders include “bar”, “baz”, and words ending in “oo” (e.g., “goo”, “moo”, “boo”).  
For more on the etymology, see [RFC 3092](https://datatracker.ietf.org/doc/html/rfc3092).

---


## 2.2 — Function Return Values (Value-Returning Functions)

**Alex &nbsp;&nbsp; February 5, 2025**

Consider the following program:

```cpp
#include <iostream>

int main()
{
    // get a value from the user
    std::cout << "Enter an integer: ";
    int num{};
    std::cin >> num;

    // print the value doubled
    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

This program is composed of two conceptual parts:  
1. Get a value from the user.  
2. Tell the user what double that value is.

Although this program is simple, what if we wanted to break it into multiple functions? Getting an integer value from the user is a well-defined job, so it would make a good candidate for a function.

### Attempting to Modularize

```cpp
// This program doesn't work
#include <iostream>

void getValueFromUser()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;
}

int main()
{
    getValueFromUser(); // Ask user for input

    int num{}; // How do we get the value from getValueFromUser() and use it to initialize this variable?

    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

When `getValueFromUser` is called, the user enters an integer, but the value is lost when the function terminates. Variable `num` is never initialized with the user's input, so the program always prints 0.

### Returning Values from Functions

To return a value from a function, two things are needed:
1. The function must specify a return type (not `void`).
2. The function must use a `return` statement to provide the value.

#### Example: Value-Returning Function

```cpp
#include <iostream>

// int is the return type
int returnFive()
{
    return 5; // return the value 5 back to the caller
}

int main()
{
    std::cout << returnFive() << '\n';      // prints 5
    std::cout << returnFive() + 2 << '\n';  // prints 7

    returnFive(); // value is returned but ignored

    return 0;
}
```

**Output:**
```
5
7
```

> **Tip:**  
> If the caller ignores the return value, it is discarded.

### Fixing the Challenge Program

```cpp
#include <iostream>

int getValueFromUser() // returns an integer value
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input; // return the value to the caller
}

int main()
{
    int num{ getValueFromUser() }; // initialize num with the return value

    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

Now, `num` is initialized with the user's input, and can be used as needed.

> **Tip:**  
> If you need to use the return value more than once, store it in a variable.

### Revisiting `main()`

- `main()` must return an `int`.
- Explicit calls to `main()` are disallowed.

```cpp
void foo()
{
    main(); // Compile error: main not allowed to be called explicitly
}

void main() // Compile error: main not allowed to have non-int return type
{
    foo();
}
```

> **Note:**  
> Some C++ compilers allow calling `main()` for C compatibility, but avoid doing so.

### Status Codes

The return value from `main()` is called a status code.  
- `0` or `EXIT_SUCCESS` means success.
- `EXIT_FAILURE` means failure.

```cpp
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
```

> **Best practice:**  
> Return `0` or `EXIT_SUCCESS` for successful termination.

### Undefined Behavior: Not Returning a Value

A value-returning function must return a value. Otherwise, undefined behavior results.

```cpp
#include <iostream>

int getValueFromUserUB() // returns int
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    // no return statement
}

int main()
{
    int num{ getValueFromUserUB() }; // undefined behavior

    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

> **Best practice:**  
> Ensure all non-void functions return a value in all cases.

### Implicit Return from `main()`

If no return statement is provided in `main()`, it implicitly returns `0`.  
However, always explicitly return a value for clarity and consistency.

### Functions Can Only Return a Single Value

A function can only return one value per call.  
The return value can be a literal, a variable, or the result of another function call.

```cpp
// Return value is the integer entered by the user
int getValueFromUser()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}
```

### Reusing Functions

Consider this redundant program:

```cpp
#include <iostream>

int main()
{
    int x{};
    std::cout << "Enter an integer: ";
    std::cin >> x;

    int y{};
    std::cout << "Enter an integer: ";
    std::cin >> y;

    std::cout << x << " + " << y << " = " << x + y << '\n';

    return 0;
}
```

Let's refactor using `getValueFromUser`:

```cpp
#include <iostream>

int getValueFromUser()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    int x{ getValueFromUser() }; // first call
    int y{ getValueFromUser() }; // second call

    std::cout << x << " + " << y << " = " << x + y << '\n';

    return 0;
}
```

**Output:**
```
Enter an integer: 5
Enter an integer: 7
5 + 7 = 12
```

This saves us from duplicating code and reduces the chance of mistakes.

> **Best practice:**  
> Follow DRY: "Don't repeat yourself". Use variables, functions, and loops to minimize redundancy.

### Conclusion

- Return values allow functions to return a single value to the caller.
- Functions help minimize redundancy and improve modularity in programs.
- Always ensure value-returning functions return a value in all cases.
- Use functions to encapsulate reusable logic and follow DRY principles.



## 2.10 — Introduction to the Preprocessor

**Alex &nbsp;&nbsp; March 5, 2025**

When you compile your project, each code file first goes through a **preprocessing phase**. The preprocessor scans your code for **preprocessor directives** (lines starting with `#`) and performs text substitutions or conditional compilation before the compiler sees your code.

### What Does the Preprocessor Do?

- Removes comments and ensures files end with a newline.
- Handles `#include` directives by inserting the contents of included files.
- Processes macros and conditional compilation.

After preprocessing, the result is called a **translation unit**, which is then compiled.

---

### Preprocessor Directives

Preprocessor directives begin with `#` and end with a newline. They are not C++ statements and have their own syntax.

**Examples:**
- `#include <iostream>`
- `#define MY_NAME "Alex"`
- `#ifdef PRINT_JOE`
- `#ifndef PRINT_BOB`
- `#endif`

> **Note:**  
> The final code passed to the compiler contains no preprocessor directives—only their output.

---

### `#include` Directive

The `#include` directive copies the contents of a file (usually a header) into your code.

```cpp
#include <iostream>
```

This replaces the directive with the contents of the `iostream` header before compilation.

---

### Macros: `#define`

Macros allow you to define text substitutions.

**Object-like macros:**
```cpp
#define MY_NAME "Alex"
```
All instances of `MY_NAME` are replaced with `"Alex"`.

**Object-like macros without substitution:**
```cpp
#define USE_YEN
```
This is used for conditional compilation.

> **Best practice:**  
> Macro names should be ALL_UPPERCASE with underscores.

---

### Conditional Compilation

Use conditional directives to include or exclude code:

```cpp
#define PRINT_JOE

int main()
{
#ifdef PRINT_JOE
    std::cout << "Joe\n";
#endif

#ifdef PRINT_BOB
    std::cout << "Bob\n";
#endif

    return 0;
}
```

- `#ifdef IDENTIFIER` — code is included if IDENTIFIER is defined.
- `#ifndef IDENTIFIER` — code is included if IDENTIFIER is NOT defined.

You can also use `#if defined(IDENTIFIER)` and `#if !defined(IDENTIFIER)`.

---

### Excluding Code: `#if 0`

Use `#if 0` to exclude blocks of code:

```cpp
int main()
{
    std::cout << "Joe\n";

#if 0
    std::cout << "Bob\n";
    std::cout << "Steve\n";
#endif

    return 0;
}
```

Change `#if 0` to `#if 1` to re-enable the code.

---

### Macro Substitution Scope

Macros are processed top-to-bottom in each file. They do not respect C++ scopes (e.g., functions). Macros defined in one file do not affect other files unless included.

**Example:**
```cpp
// Alex.h
#define MY_NAME "Alex"

// main.cpp
#include "Alex.h"
#include <iostream>

int main()
{
    std::cout << "My name is: " << MY_NAME << '\n';
    return 0;
}
```

---

### Summary

- The preprocessor handles directives before compilation.
- Use `#include` for headers, `#define` for macros, and conditional directives for selective compilation.
- Macros are global within a file and do not respect C++ scopes.
- Prefer modern C++ features over macros when possible.

---

## 4.12 — Introduction to Type Conversion and `static_cast`

**Alex &nbsp;&nbsp; March 3, 2025**

### Implicit Type Conversion

C++ automatically converts values between fundamental types when needed. This is called *implicit type conversion*. For example:

```cpp
#include <iostream>

void print(double x) // expects a double
{
    std::cout << x << '\n';
}

int main()
{
    print(5); // int 5 is implicitly converted to double 5.0
    return 0;
}
```

Output:
```
5
```
> Floating-point values with no fractional part print without decimals (e.g., 5.0 prints as 5).

Implicit conversion does not modify the original value or variable—it produces a new temporary value of the target type.

### Implicit Conversion Warnings

Some conversions may lose information, such as converting a `double` to an `int`:

```cpp
#include <iostream>

void print(int x)
{
    std::cout << x << '\n';
}

int main()
{
    print(5.5); // double 5.5 implicitly converted to int 5 (fractional part lost)
    return 0;
}
```

Output:
```
5
```
> The compiler will warn about possible data loss. Prefer brace initialization to catch unsafe conversions:

```cpp
int x{5.5}; // error: double to int not safe
```

### Explicit Type Conversion with `static_cast`

To explicitly convert between types, use `static_cast`:

```cpp
#include <iostream>

void print(int x)
{
    std::cout << x << '\n';
}

int main()
{
    print(static_cast<int>(5.5)); // explicit conversion, no warning
    return 0;
}
```

### Using `static_cast` to Convert `char` to `int`

```cpp
#include <iostream>

int main()
{
    char ch{97}; // ASCII for 'a'
    std::cout << ch << " has value " << static_cast<int>(ch) << '\n';
    return 0;
}
```

Output:
```
a has value 97
```

### Sign Conversions

You can convert between signed and unsigned types:

```cpp
#include <iostream>

int main()
{
    unsigned int u1{5};
    int s1{static_cast<int>(u1)};
    std::cout << s1 << '\n'; // prints 5

    int s2{5};
    unsigned int u2{static_cast<unsigned int>(s2)};
    std::cout << u2 << '\n'; // prints 5
    return 0;
}
```

If the value cannot be represented in the destination type, modulo wrapping occurs:

```cpp
#include <iostream>

int main()
{
    int s{-1};
    std::cout << static_cast<unsigned int>(s) << '\n'; // prints 4294967295

    unsigned int u{4294967295};
    std::cout << static_cast<int>(u) << '\n'; // prints -1 (C++20)
    return 0;
}
```

### `std::int8_t` and `std::uint8_t` Behave Like `char`

```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::int8_t myInt{65};
    std::cout << myInt << '\n'; // prints 'A' on most systems
    std::cout << static_cast<int>(myInt) << '\n'; // always prints 65
    return 0;
}
```

Input may also be affected:

```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::cout << "Enter a number between 0 and 127: ";
    std::int8_t myInt{};
    std::cin >> myInt;
    std::cout << "You entered: " << static_cast<int>(myInt) << '\n';
    return 0;
}
```

Sample run:
```
Enter a number between 0 and 127: 35
You entered: 51
```
> Input is interpreted as characters, not numbers.

### Summary

- Implicit conversions happen automatically, but may lose data.
- Use `static_cast` for explicit conversions and to suppress warnings.
- Some types (like `std::int8_t`) may behave unexpectedly due to being treated as `char`.
- Prefer brace initialization to catch unsafe conversions.
- Modulo wrapping occurs when converting values outside the destination type's range.


## 5.1 — Constant Variables (Named Constants)

**Alex &nbsp;&nbsp; October 17, 2024**

### Introduction to Constants

A constant is a value that cannot be changed during program execution. C++ supports two kinds of constants:

- **Named constants**: Associated with an identifier (symbolic constants).
- **Literal constants**: Not associated with an identifier.

This lesson covers named constants via constant variables. Object-like macros and enumerated constants are discussed elsewhere.

---

### Defining Constant Variables

A constant variable is a variable whose value cannot be changed after initialization. Use the `const` keyword to declare a constant variable:

```cpp
const double gravity { 9.8 };  // preferred style
int const sidesInSquare { 4 }; // "east const" style (less common)
```

**Best practice:**  
Place `const` before the type for readability.

---

### Initialization Requirement

Constant variables must be initialized when defined and cannot be assigned new values:

```cpp
int main()
{
    const double gravity; // error: must be initialized
    gravity = 9.9;        // error: cannot assign to const

    return 0;
}
```

You can initialize a const variable from another variable:

```cpp
#include <iostream>

int main()
{
    std::cout << "Enter your age: ";
    int age{};
    std::cin >> age;

    const int constAge { age }; // initialized from non-const

    age = 5;      // ok
    constAge = 6; // error

    return 0;
}
```

---

### Naming Conventions

Common conventions for const variable names:

- ALL_UPPERCASE (e.g., `EARTH_GRAVITY`)
- Intercapped with 'k' prefix (e.g., `kEarthGravity`)
- Regular variable naming (e.g., `earthGravity`)

**Best practice:**  
Use the same naming convention as for non-const variables.

---

### Const Function Parameters

Function parameters can be made const:

```cpp
#include <iostream>

void printInt(const int x)
{
    std::cout << x << '\n';
}

int main()
{
    printInt(5);
    printInt(6);

    return 0;
}
```

**Best practice:**  
Do not use `const` for value parameters.

---

### Const Return Values

You can declare a function's return value as const:

```cpp
#include <iostream>

const int getValue()
{
    return 5;
}

int main()
{
    std::cout << getValue() << '\n';
    return 0;
}
```

For fundamental types, the `const` qualifier on return values is ignored.

**Best practice:**  
Do not use `const` when returning by value.

---

### Why Use Constant Variables?

- Prevents accidental modification.
- Enables compiler optimizations.
- Reduces program complexity.

**Best practice:**  
Make variables constant whenever possible (except for value parameters and value return types).

---

### Object-like Macros as Named Constants

Macros can also define named constants:

```cpp
#include <iostream>
#define MY_NAME "Alex"

int main()
{
    std::cout << "My name is: " << MY_NAME << '\n';
    return 0;
}
```

---

### Prefer Constant Variables Over Macros

Macros do not follow C++ scoping rules and can cause unexpected substitutions and errors:

```cpp
#include <iostream>

void someFcn()
{
    #define gravity 9.8
}

void printGravity(double gravity)
{
    std::cout << "gravity: " << gravity << '\n';
}

int main()
{
    printGravity(3.71);
    return 0;
}
```

**Best practice:**  
Prefer constant variables over macros for named constants.

---

### Sharing Constants Across Multiple Files

For global constants used throughout a program, declare them in a central location. See lesson 7.10 for details.

---

### Type Qualifiers

A type qualifier modifies how a type behaves. C++ has two: `const` and `volatile`.

- **cv-unqualified type**: No qualifiers (e.g., `int`)
- **cv-qualified type**: With qualifiers (e.g., `const int`)

---

**Joke:**  
Q: How do you know if a C++ developer is qualified?  
A: You look at their CV.


## 7.2 — User-defined namespaces and the scope resolution operator

**Alex &nbsp;&nbsp; June 28, 2024**

Namespaces help prevent naming collisions by grouping identifiers into named scopes. As projects grow, the risk of collisions increases, so using namespaces is essential for modular code.

### Defining a Namespace

Use the `namespace` keyword followed by an identifier and curly braces:

```cpp
namespace MyNamespace
{
    int value{ 42 };
    void printValue()
    {
        std::cout << value << '\n';
    }
}
```

### Accessing Namespace Members

Use the scope resolution operator `::` to access members:

```cpp
std::cout << MyNamespace::value << '\n';
MyNamespace::printValue();
```

### Example: Resolving Naming Collisions

Suppose two files define functions with the same name:

```cpp
namespace Foo
{
    int doSomething(int x, int y) { return x + y; }
}

namespace Goo
{
    int doSomething(int x, int y) { return x - y; }
}

int main()
{
    std::cout << Foo::doSomething(4, 3) << '\n'; // 7
    std::cout << Goo::doSomething(4, 3) << '\n'; // 1
    return 0;
}
```

### Scope Resolution Operator with Global Namespace

Prefixing with `::` accesses the global namespace:

```cpp
void print() { std::cout << "Global\n"; }

namespace Foo
{
    void print() { std::cout << "Foo\n"; }
    void callPrints()
    {
        print();    // Foo::print()
        ::print();  // global print()
    }
}
```

### Forward Declarations in Namespaces

Forward declarations must be inside the same namespace:

```cpp
// add.h
namespace Math
{
    int add(int x, int y);
}

// add.cpp
namespace Math
{
    int add(int x, int y) { return x + y; }
}
```

### Multiple Namespace Blocks

You can extend a namespace in multiple places/files:

```cpp
namespace Math
{
    constexpr double pi{ 3.14159 };
}

namespace Math
{
    constexpr double e{ 2.71828 };
}
```

### Nested Namespaces

Namespaces can be nested:

```cpp
namespace Company
{
    namespace Project
    {
        void run();
    }
}

// C++17 style
namespace Company::Project
{
    void run() { /* ... */ }
}
```

### Namespace Aliases

Shorten long namespace names:

```cpp
namespace LongName::SubName
{
    void func();
}

namespace LN = LongName::SubName;

LN::func(); // calls LongName::SubName::func()
```

### Best Practices

- Use namespaces to avoid naming collisions.
- Prefer capitalized namespace names for user-defined namespaces.
- Avoid extending the `std` namespace.
- Limit nesting to three levels or fewer.
- Namespace library code for distribution.

---

## 7.3 — Local variables

**Alex &nbsp;&nbsp; June 9, 2024**

In lesson 2.5 -- Introduction to local scope, we introduced local variables, which are variables that are defined inside a function (including function parameters).

It turns out that C++ actually doesn’t have a single attribute that defines a variable as being a local variable. Instead, local variables have several different properties that differentiate how these variables behave from other kinds of (non-local) variables. We’ll explore these properties in this and upcoming lessons.

### Scope of Local Variables

An identifier’s scope determines where it can be accessed within the source code. When an identifier can be accessed, it is *in scope*. When it cannot, it is *out of scope*. Scope is a compile-time property, and using an identifier out of scope causes a compile error.

Local variables have **block scope**: they are in scope from their point of definition to the end of the block in which they are defined.

```cpp
int main()
{
    int i { 5 };      // i enters scope here
    double d { 4.0 }; // d enters scope here

    return 0;
} // d and i go out of scope here
```

Function parameters are also considered part of the function body block's scope:

```cpp
int max(int x, int y) // x and y enter scope here
{
    int max{ (x > y) ? x : y }; // max enters scope here
    return max;
} // max, y, and x leave scope here
```

### Unique Names Within Scope

Variable names must be unique within a given scope:

```cpp
void someFunction(int x)
{
    int x{}; // error: name collision with function parameter
}
```

### Automatic Storage Duration

Local variables have **automatic storage duration**: they are created at the point of definition and destroyed at the end of the block.

```cpp
int main()
{
    int i { 5 };      // created and initialized here
    double d { 4.0 }; // created and initialized here

    return 0;
} // destroyed here
```

Local variables are sometimes called *automatic variables*.

### Local Variables in Nested Blocks

Local variables can be defined inside nested blocks:

```cpp
int main()
{
    int x { 5 }; // x enters scope and is created here

    { // nested block
        int y { 7 }; // y enters scope and is created here
        std::cout << x << " + " << y << " = " << x + y << '\n';
    } // y goes out of scope and is destroyed here

    // y cannot be used here

    return 0;
} // x goes out of scope and is destroyed here
```

Variables defined in the outer block are visible inside nested blocks.

### No Linkage for Local Variables

Local variables have **no linkage**: each declaration refers to a unique object.

```cpp
int main()
{
    int x { 2 }; // local variable, no linkage

    {
        int x { 3 }; // refers to a different object than the previous x
    }

    return 0;
}
```

Scope determines where a single identifier can be used; linkage determines whether multiple declarations refer to the same object.

### Define Variables in the Most Limited Scope

If a variable is only used within a nested block, define it inside that block:

```cpp
int main()
{
    {
        int y { 5 };
        std::cout << y << '\n';
    }
    // y cannot be used here

    return 0;
}
```

If a variable is needed in an outer block, declare it there:

```cpp
int main()
{
    int y { 5 };

    {
        int x{};
        std::cin >> x;
        if (x == 4)
            y = 4;
    }

    std::cout << y;

    return 0;
}
```

### Best Practice

Define variables in the most limited existing scope. Avoid creating new blocks solely to limit variable scope; consider using functions instead.



## 7.4 — Introduction to global variables

**Alex &nbsp;&nbsp; June 9, 2024**

In lesson 7.3 -- Local variables, we covered that local variables are variables defined inside a function body. Local variables have block scope (are only visible within the block they are declared in), and have automatic duration (they are created at the point of definition and destroyed when the block is exited).

### Declaring global variables

In C++, variables can also be declared outside of a function. Such variables are called **global variables**. By convention, global variables are declared at the top of a file, below the includes, in the global namespace.

```cpp
#include <iostream>

// Variables declared outside of a function are global variables
int g_x {}; // global variable g_x

void doSomething()
{
    // global variables can be seen and used everywhere in the file
    g_x = 3;
    std::cout << g_x << '\n';
}

int main()
{
    doSomething();
    std::cout << g_x << '\n';

    // global variables can be seen and used everywhere in the file
    g_x = 5;
    std::cout << g_x << '\n';

    return 0;
}
// g_x goes out of scope here
```

**Output:**
```
3
3
5
```

### The scope of global variables

Identifiers declared in the global namespace have **global namespace scope** (commonly called global scope, and sometimes informally called file scope), which means they are visible from the point of declaration until the end of the file in which they are declared.

Once declared, a global variable can be used anywhere in the file from that point onward. In the above example, global variable `g_x` is used in both functions `doSomething()` and `main()`.

Global variables can also be defined inside a user-defined namespace. Here is the same example as above, but `g_x` has been moved from the global scope into user-defined namespace `Foo`:

```cpp
#include <iostream>

namespace Foo // Foo is defined in the global scope
{
    int g_x {}; // g_x is now inside the Foo namespace, but is still a global variable
}

void doSomething()
{
    // global variables can be seen and used everywhere in the file
    Foo::g_x = 3;
    std::cout << Foo::g_x << '\n';
}

int main()
{
    doSomething();
    std::cout << Foo::g_x << '\n';

    // global variables can be seen and used everywhere in the file
    Foo::g_x = 5;
    std::cout << Foo::g_x << '\n';

    return 0;
}
```

Although the identifier `g_x` is now limited to the scope of namespace `Foo`, that name is still globally accessible (via `Foo::g_x`), and `g_x` is still a global variable.

> **Key insight:**  
> Variables declared inside a namespace are also global variables.

**Best practice:**  
Prefer defining global variables inside a namespace rather than in the global namespace.

### Global variables have static duration

Global variables are created when the program starts (before `main()` begins execution), and destroyed when it ends. This is called **static duration**. Variables with static duration are sometimes called *static variables*.

### Naming global variables

By convention, some developers prefix global variable identifiers with `g` or `g_` to indicate that they are global. This prefix serves several purposes:

- It helps avoid naming collisions with other identifiers in the global namespace.
- It helps prevent inadvertent name shadowing (see lesson 7.5).
- It helps indicate that the prefixed variables persist beyond the scope of the function, and thus any changes we make to them will also persist.

Global variables defined inside a user-defined namespace often omit the prefix (since the first two points above are not an issue in this case, and we can infer that a variable is a global when we see a prepended namespace name). However, it doesn’t hurt if you want to keep the prefix as a more visible reminder of the third point.

**Best practice:**  
Consider using a `g` or `g_` prefix when naming global variables (especially those defined in the global namespace), to help differentiate them from local variables and function parameters.

> **Author’s note:**  
> Using prefixes to represent the scope or duration of a variable (such as `g_` for global, `s_` for static, and `m_` for member) adds value and is not the same as Hungarian notation for types.

### Global variable initialization

Unlike local variables, which are uninitialized by default, variables with static duration are **zero-initialized by default**.

Non-constant global variables can be optionally initialized:

```cpp
int g_x;       // no explicit initializer (zero-initialized by default)
int g_y {};    // value initialized (resulting in zero-initialization)
int g_z { 1 }; // list initialized with specific value
```

### Constant global variables

Just like local variables, global variables can be constant. As with all constants, constant global variables must be initialized.

```cpp
#include <iostream>

const int g_x;     // error: constant variables must be initialized
constexpr int g_w; // error: constexpr variables must be initialized

const int g_y { 1 };     // const global variable g_y, initialized with a value
constexpr int g_z { 2 }; // constexpr global variable g_z, initialized with a value

void doSomething()
{
    // global variables can be seen and used everywhere in the file
    std::cout << g_y << '\n';
    std::cout << g_z << '\n';
}

int main()
{
    doSomething();

    // global variables can be seen and used everywhere in the file
    std::cout << g_y << '\n';
    std::cout << g_z << '\n';

    return 0;
}
// g_y and g_z go out of scope here
```

> See lesson 7.10 for sharing global constants across multiple files.

### A word of caution about (non-constant) global variables

New programmers are often tempted to use lots of global variables, because they can be used without having to explicitly pass them to every function that needs them. However, use of non-constant global variables should generally be avoided altogether! We’ll discuss why in lesson 7.8.

### Quick Summary

```cpp
// Non-constant global variables
int g_x;                 // defines non-initialized global variable (zero initialized by default)
int g_x {};              // defines explicitly value-initialized global variable
int g_x { 1 };           // defines explicitly initialized global variable

// Const global variables
const int g_y;           // error: const variables must be initialized
const int g_y { 2 };     // defines initialized global const

// Constexpr global variables
constexpr int g_y;       // error: constexpr variables must be initialized
constexpr int g_y { 3 }; // defines initialized global constexpr
```



> ## 🚨 VERY VERY IMPORTANT CONCEPT: Categories of "Specifiers" in C++
>
> **Specifiers** in C++ are keywords that *fundamentally* change how variables and functions behave. Understanding them is **critical** for mastering C++!
>
> ### 1. Storage Class Specifiers
> - **Purpose:** Control *linkage* and *storage duration* of variables.
> - **Examples:**  
>   `static`, `extern`, `mutable`, `thread_local`
>
> ### 2. Type Qualifiers (cv-qualifiers)
> - **Purpose:** Modify the *type* of an object, affecting mutability and access.
> - **Examples:**  
>   `const`, `volatile`, `restrict` (C only), `mutable` (special meaning in classes)
>
> ### 3. Function Specifiers
> - **Purpose:** Change *function behavior* and properties.
> - **Examples:**  
>   `inline`, `virtual`, `explicit`, `constexpr`, etc.
>
> ---
>
> **⚡ Mastery of these specifiers is ABSOLUTELY ESSENTIAL for understanding:**
> - Object lifetimes
> - Type safety
> - Function semantics
>
> <span style="color:red; font-weight:bold;">Do not skip this concept!</span>
## 7.6 — Internal Linkage

**Alex &nbsp;&nbsp; January 30, 2025**

---

### What is Internal Linkage?

Internal linkage restricts an identifier's visibility to a single translation unit (source file and its includes). Identifiers with internal linkage are **not accessible from other files**—even if they have the same name and type elsewhere.

> **Key Insight:**  
> Identifiers with internal linkage are either invisible to the linker or marked for use only in their translation unit.

---

### Internal Linkage for Global Variables

- **Non-constant globals**: Use `static` to give internal linkage.
- **const/constexpr globals**: Have internal linkage by default.

```cpp
#include <iostream>

static int g_x{};        // internal linkage via static
const int g_y{ 1 };      // internal linkage by default
constexpr int g_z{ 2 };  // internal linkage by default

int main()
{
    std::cout << g_x << ' ' << g_y << ' ' << g_z << '\n';
    return 0;
}
```

**Multiple files can have their own internal variables with the same name:**

**a.cpp**
```cpp
constexpr int g_x { 2 }; // only accessible in a.cpp
```

**main.cpp**
```cpp
#include <iostream>
static int g_x { 3 }; // only accessible in main.cpp

int main()
{
    std::cout << g_x << '\n'; // prints 3
    return 0;
}
```

---

### Why const Globals Have Internal Linkage

- **Const objects** can be used in constant expressions and propagated via header files.
- Internal linkage allows each translation unit to have its own definition, avoiding ODR (One Definition Rule) violations.
- Enables safe use of constants in headers included in multiple files.

---

### Internal Linkage for Functions

Functions default to **external linkage**, but can be made internal with `static`:

**add.cpp**
```cpp
static int add(int x, int y)
{
    return x + y;
}
```

**main.cpp**
```cpp
#include <iostream>
int add(int x, int y); // forward declaration

int main()
{
    std::cout << add(3, 4) << '\n'; // linker error: add is not accessible
    return 0;
}
```

---

### Modern C++: Prefer Unnamed Namespaces

- `static` for internal linkage is less common now.
- **Unnamed namespaces** provide internal linkage for more identifier types and are preferred for multiple internal items.

---

### When to Use Internal Linkage?

- To **hide identifiers** from other files (e.g., helper functions, private globals).
- To **avoid naming collisions** across translation units.

> **Best Practice:**  
> Give internal linkage to identifiers you explicitly want to keep private to a file.  
> Consider unnamed namespaces for broader internal linkage.

---

### Quick Summary

```cpp
// Internal global variables:
static int g_x;          // zero-initialized internal global
static int g_x{ 1 };     // initialized internal global

const int g_y { 2 };     // initialized internal global const
constexpr int g_y { 3 }; // initialized internal global constexpr

// Internal functions:
static int foo() {};     // internal function
```

---

> See lesson 7.12 for a comprehensive summary of scope, duration, and linkage.


## 7.7 — External linkage and variable forward declarations

**Alex &nbsp;&nbsp; December 11, 2024**

In the prior lesson, we discussed internal linkage, which restricts an identifier's visibility to a single file. Now, let's explore **external linkage**.

### What is External Linkage?

Identifiers with external linkage can be accessed from multiple files in a program. This allows sharing functions and variables across translation units.

> **Key Insight:**  
> Identifiers with external linkage are visible to the linker, enabling cross-file access and deduplication.

---

### Functions Have External Linkage by Default

Functions are externally linked unless marked otherwise. To use a function from another file, provide a **forward declaration** in the file where you want to use it.

**Example:**

**a.cpp**
```cpp
#include <iostream>

void sayHi()
{
    std::cout << "Hi!\n";
}
```

**main.cpp**
```cpp
void sayHi(); // forward declaration

int main()
{
    sayHi(); // linker connects this call to a.cpp's definition
    return 0;
}
```

Output:
```
Hi!
```

If `sayHi()` had internal linkage (`static`), the linker would not be able to connect the call, resulting in a linker error.

---

### Global Variables with External Linkage

Global variables are **external by default** (except for `const` and `constexpr`, which are internal unless marked `extern`). To use a global variable from another file, declare it with `extern` (without initialization) in the file where you want to use it.

**Example:**

**a.cpp**
```cpp
int g_x { 2 };              // non-const globals: external by default
extern const int g_y { 3 }; // const global: external linkage via extern
```

**main.cpp**
```cpp
#include <iostream>

extern int g_x;       // forward declaration
extern const int g_y; // forward declaration

int main()
{
    std::cout << g_x << ' ' << g_y << '\n'; // prints 2 3
    return 0;
}
```

---

### The `extern` Keyword

- For **non-const globals**, `extern` is used for forward declarations only.
- For **const/constexpr globals**, `extern` is required for external linkage and for forward declarations.

**Note:**  
Do not use `extern` with an initializer for non-const globals unless you intend a definition. Compilers may warn about suspicious usage.

---

### Forward Declaration Syntax

```cpp
// Non-constant
int g_x;        // definition
int g_x { 1 };  // definition with initializer
extern int g_x; // forward declaration

// Constant
extern const int g_y { 1 }; // definition (must be initialized)
extern const int g_y;       // forward declaration
```

---

### Limitations with `constexpr`

`constexpr` variables cannot be forward declared, as their value must be known at compile time. You can forward declare a `constexpr` as `const`, but it will be treated as a runtime constant.

---

### Best Practices

- Use `extern` for global variable forward declarations and const global variable definitions.
- Do **not** use `extern` for non-const global variable definitions (they are implicitly external).
- Avoid using `extern` with initializers for non-const globals unless necessary.

---

### Quick Summary

```cpp
// Forward declarations (extern, no initializer):
extern int g_y;                 // non-const global
extern const int g_y;           // const global
extern constexpr int g_y;       // not allowed

// External global variable definitions:
int g_x;                        // non-initialized
int g_x { 1 };                  // initialized

// External const global variable definitions:
extern const int g_x { 2 };     // initialized const
extern constexpr int g_x { 3 }; // initialized constexpr
```

See lesson 7.12 for a comprehensive summary of scope, duration, and linkage.


## 7.8 — Why (non-const) global variables are evil

**Alex &nbsp;&nbsp; January 29, 2025**

---

> **"Avoid global variables!"**  
> — Every experienced C++ developer, ever

Global variables are one of the most abused features in C++. While they seem convenient in small programs, they become a source of bugs and confusion in larger projects. This lesson explains why **non-const global variables** are especially problematic.

---

### The Dangers of Non-const Global Variables

Non-const global variables can be changed by any function, at any time, from anywhere in your program. This makes your program's state unpredictable and hard to reason about.

**Example: Unintended Modification**

```cpp
#include <iostream>

int g_mode; // global variable (zero-initialized)

void doSomething()
{
    g_mode = 2; // modifies global variable
}

int main()
{
    g_mode = 1; // sets global variable

    doSomething(); // changes g_mode unexpectedly

    if (g_mode == 1)
        std::cout << "No threat detected.\n";
    else
        std::cout << "Launching nuclear missiles...\n";

    return 0;
}
```

> **Result:**  
> The programmer expects `g_mode` to be `1`, but `doSomething()` changed it to `2`.  
> The program's behavior is now unpredictable!

---

### Why Are Global Variables Problematic?

- **Unpredictable State:** Any function can change a global variable, making it hard to track changes.
- **Difficult Debugging:** You may need to search the entire codebase to find where a global variable is modified.
- **Reduced Modularity:** Functions that rely on globals are less reusable and harder to test.
- **Initialization Order Issues:** The order in which global variables are initialized (especially across files) is not guaranteed.

---

### The Static Initialization Order Fiasco

Global variables are initialized before `main()` runs, but the order is not always clear—especially across multiple files.

**Example: Ambiguous Initialization**

```cpp
#include <iostream>

int initX();
int initY();

int g_x{ initX() }; // g_x initialized first
int g_y{ initY() };

int initX() { return g_y; } // g_y not initialized yet!
int initY() { return 5; }

int main()
{
    std::cout << g_x << ' ' << g_y << '\n'; // prints: 0 5
}
```

> **Warning:**  
> Never initialize a global variable using another global variable from a different file.

---

### When Are Non-const Globals Acceptable?

Rarely! Only use a non-const global if:
- There should only ever be **one** instance of the thing it represents.
- Its use is **ubiquitous** throughout your program.

**Examples:**  
- Logging objects  
- Random number generators  
- `std::cout` and `std::cin` (implemented as globals in the standard library)

---

### Best Practices for Global Variables

1. **Prefer Local Variables:** Use local variables and pass them as function arguments.
2. **Namespace Your Globals:** Place globals inside a namespace to avoid collisions.

    ```cpp
    namespace constants
    {
        constexpr double gravity { 9.8 };
    }
    std::cout << constants::gravity << '\n';
    ```

3. **Encapsulate Access:** Make globals `static` or `const` and provide access functions.

    ```cpp
    namespace constants
    {
        constexpr double gravity { 9.8 };
    }
    double getGravity() { return constants::gravity; }
    ```

4. **Pass as Arguments:** Write functions that accept values as parameters instead of using globals directly.

    ```cpp
    double instantVelocity(int time, double gravity)
    {
        return gravity * time;
    }
    std::cout << instantVelocity(5, constants::gravity) << '\n';
    ```

---

### A C++ Joke

> **Q:** What's the best naming prefix for a global variable?  
> **A:** `//`  
> *Because every global deserves a comment!*

---

**Summary:**

- Non-const global variables make code unpredictable and hard to maintain.
- Prefer local variables, namespaces, encapsulation, and parameter passing.
- Only use non-const globals when absolutely necessary—and document them well!
## 7.9 — How to use global constants safely and effectively

**Alex &nbsp;&nbsp; January 30, 2025**

---

Global constants are a powerful tool for sharing immutable values across multiple files in a project. Used correctly, they improve code clarity, maintainability, and safety. This lesson covers best practices for defining, sharing, and using global constants in C++.

---

### Why Use Global Constants?

- **Consistency:** Ensures the same value is used everywhere.
- **Maintainability:** Changing the constant in one place updates all usages.
- **Safety:** Prevents accidental modification.

---

### Defining Global Constants

Prefer `constexpr` for compile-time constants, and `const` for runtime constants. Place global constants inside a namespace to avoid naming collisions.

**Example:**

```cpp
// constants.h
#pragma once

namespace constants
{
    constexpr double gravity { 9.8 };
    constexpr int maxPlayers { 4 };
}
```

---

### Sharing Global Constants Across Multiple Files

1. **Declare constants in a header file** (e.g., `constants.h`).
2. **Include the header** wherever the constants are needed.

**Example usage:**

```cpp
// main.cpp
#include <iostream>
#include "constants.h"

int main()
{
    std::cout << "Gravity is " << constants::gravity << '\n';
    std::cout << "Max players: " << constants::maxPlayers << '\n';
    return 0;
}
```

---

### Best Practices

- **Use namespaces** for all global constants.
- **Prefer `constexpr`** for values known at compile time.
- **Avoid macros** for constants; use typed variables instead.
- **Never use non-const globals for shared values.**
- **Document constants** clearly in the header file.

---

### Common Pitfalls

- **Multiple definitions:** Only define the constant once, in the header, using `constexpr` or `inline const` (C++17+).
- **Initialization order:** Constants are safe; avoid using non-const globals.
- **Name collisions:** Namespaces prevent accidental overlap.

---

### Quick Reference

```cpp
// constants.h
namespace constants
{
    constexpr double pi { 3.141592653589793 };
    constexpr int screenWidth { 1024 };
    constexpr int screenHeight { 768 };
}
```

---

**Summary:**

- Use global constants for shared, immutable values.
- Place them in a namespace and a header file.
- Prefer `constexpr` and avoid macros.
- Never use non-const global variables for shared data.

---

---
## 7.11 — Static Local Variables

**Alex &nbsp;&nbsp; December 26, 2024**

The term `static` is one of the most confusing in C++, because it has different meanings depending on context. Previously, we learned that global variables have *static duration* (created at program start, destroyed at program end), and that `static` gives global identifiers *internal linkage* (visible only in their file).

This lesson explores the use of `static` for **local variables**.

---

### Static Local Variables

By default, local variables have *automatic duration*: they are created when the block is entered and destroyed when the block is exited.

Using the `static` keyword on a local variable changes its duration to *static duration*. This means the variable is created at program start and destroyed at program end—just like a global variable. The variable retains its value between function calls.

#### Example: Automatic Duration

```cpp
#include <iostream>

void incrementAndPrint()
{
    int value{ 1 }; // automatic duration
    ++value;
    std::cout << value << '\n';
} // value is destroyed here

int main()
{
    incrementAndPrint();
    incrementAndPrint();
    incrementAndPrint();
    return 0;
}
```

**Output:**
```
2
2
2
```

Each call creates a new `value`, increments it, prints 2, then destroys it.

#### Example: Static Duration

```cpp
#include <iostream>

void incrementAndPrint()
{
    static int s_value{ 1 }; // static duration
    ++s_value;
    std::cout << s_value << '\n';
} // s_value is not destroyed here

int main()
{
    incrementAndPrint();
    incrementAndPrint();
    incrementAndPrint();
    return 0;
}
```

**Output:**
```
2
3
4
```

`s_value` is created once at program start, and its value persists across calls.

---

### Initialization Details

- Static local variables with a constexpr initializer are initialized at program start.
- If no initializer or a non-constexpr initializer is provided, they are zero-initialized at program start, and then initialized the first time the definition is encountered.
- Initialization only happens once.

**Best practice:**  
Always initialize static local variables.

**Tip:**  
Prefix static local variables with `s_` (e.g., `s_value`) for clarity.

---

### Use Case: Unique ID Generation

Static local variables are ideal for generating unique IDs:

```cpp
int generateID()
{
    static int s_itemID{ 0 };
    return s_itemID++; // returns current value, then increments
}
```

Each call returns a unique number. The variable is local (not accessible elsewhere), but persists for the program's lifetime.

---

### Scope and Lifetime

- **Scope:** Block scope (only accessible in the function/block).
- **Lifetime:** Static duration (exists until program ends).

Static local variables combine the safety of local scope with the persistence of global variables.

---

### Static Local Constants

Static local variables can be `const` or `constexpr`. This is useful for expensive initialization:

```cpp
const static int s_expensiveValue{ expensiveCalculation() };
```

The value is computed once and reused on every function call.

---

### Pitfall: Using Static Locals to Alter Flow

Static local variables can make functions non-reusable and unpredictable if used to alter control flow:

```cpp
#include <iostream>

int getInteger()
{
    static bool s_isFirstCall{ true };

    if (s_isFirstCall)
    {
        std::cout << "Enter an integer: ";
        s_isFirstCall = false;
    }
    else
    {
        std::cout << "Enter another integer: ";
    }

    int i{};
    std::cin >> i;
    return i;
}
```

If you call `getInteger()` multiple times, the prompt changes after the first call. This internal state makes the function hard to reuse and understand.

**Better approach:** Pass state as a parameter:

```cpp
constexpr bool g_firstCall{ true };

int getInteger(bool bFirstCall)
{
    if (bFirstCall)
        std::cout << "Enter an integer: ";
    else
        std::cout << "Enter another integer: ";

    int i{};
    std::cin >> i;
    return i;
}
```

Now, the caller controls the prompt, making the function reusable.

---

### Summary and Best Practices

- Use static local variables for values that must persist across function calls and are unique for the program's lifetime.
- Prefer `const` static locals for expensive initialization.
- Avoid non-const static locals for altering control flow or when the variable should be resettable.
- Consider passing state as a parameter for reusable functions.
- Prefix static locals with `s_` for clarity.

**Advanced:**  
For multiple independent persistent values (e.g., multiple ID generators), consider using functors or classes.

---




---

## 7.12 — Summary: Scope, Duration, Linkage, and Storage Class Specifiers

**Alex &nbsp;&nbsp; January 31, 2025**

This section summarizes the most important concepts for understanding how variables and functions behave in C++: **scope**, **duration**, **linkage**, and **storage class specifiers**.

---

### 1. Scope

- **Scope** determines where an identifier can be accessed in source code.
    - **Block (local) scope:** Exists only within the `{}` block where declared.
    - **Global scope:** Exists from its declaration to the end of the file (and possibly in other files, depending on linkage).

**Example:**
```cpp
#include <iostream>

int g_var { 10 }; // global scope

void foo()
{
    int x { 5 }; // block scope
    std::cout << x << '\n';     // accessible
    std::cout << g_var << '\n'; // accessible
}

int main()
{
    foo();
    // std::cout << x; // error: x is out of scope
}
```

**Rule of thumb:**  
Local variables vanish after their block ends.  
Globals exist throughout the file, unless linkage restricts them.

---

### 2. Duration

- **Duration** is when a variable is created and destroyed (its lifetime).
    - **Automatic duration:** Created when definition is reached; destroyed when block ends (default for locals and parameters).
    - **Static duration:** Created when the program starts; destroyed when the program ends (globals and static locals).
    - **Dynamic duration:** Created and destroyed manually (with `new`/`delete`).

**Example:**
```cpp
void test() {
    int x{5}; // automatic duration
} // destroyed here

void counter() {
    static int s_val{0}; // static duration
    ++s_val;
    std::cout << s_val << '\n';
}

int* ptr = new int(42); // dynamic duration
delete ptr; // must explicitly destroy
```

**Rule of thumb:**  
Automatic = temporary  
Static = whole program  
Dynamic = you manage

---

### 3. Linkage

- **Linkage** determines if an identifier can be shared across files.
    - **No linkage:** Unique each time declared (locals, block enums/classes).
    - **Internal linkage:** Shared only within one translation unit (file). (`static` globals, `const` globals, `static` functions)
    - **External linkage:** Shared across multiple files. (non-const globals, non-static functions, `extern` variables)

**Example:**
```cpp
// No linkage
void foo() {
    int x{5}; // unique to this function
}

// Internal linkage
static int g_val { 10 }; // only visible in this file
const int g_const { 20 }; // also internal by default

// External linkage
// globals.cpp
int g_val { 10 }; // definition

// main.cpp
extern int g_val; // forward declaration
```

**Rule of thumb:**  
Local vars: no linkage.  
Globals: internal by default if const or static, external otherwise.

---

### 4. Storage Class Specifiers

- **Keywords that affect duration and linkage:**
    - `static` → static duration + internal linkage
    - `extern` → static duration + external linkage
    - `thread_local` → one variable per thread
    - `mutable` → allows modification in const objects

---

### 5. Summary Table

| Type                  | Example                   | Scope   | Duration   | Linkage   |
|-----------------------|--------------------------|---------|------------|-----------|
| Local variable        | `int x;`                 | Block   | Automatic  | None      |
| Static local          | `static int s_x;`        | Block   | Static     | None      |
| Dynamic local         | `int* p{new int};`       | Block   | Dynamic    | None      |
| Function param        | `void f(int x);`         | Block   | Automatic  | None      |
| Internal global       | `static int g_x;`        | Global  | Static     | Internal  |
| External global       | `int g_x;`               | Global  | Static     | External  |
| Inline global (C++17) | `inline int g_x;`        | Global  | Static     | External  |
| Constexpr global      | `constexpr int g_x{1};`  | Global  | Static     | Internal  |
| Extern const          | `extern const int g_x;`  | Global  | Static     | External  |

---

### 🚀 Best Practices

- Prefer locals over globals (minimize scope).
- Use `const`/`constexpr` wherever possible.
- Use static locals only when remembering state is intentional.
- Use `extern` only when you really need cross-file globals.

---
